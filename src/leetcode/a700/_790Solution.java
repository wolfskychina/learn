package leetcode.a700;

/**
 * 两行N列的多米诺骨牌的拼装方式
 * 一共有两种骨牌
 */
public class _790Solution {

    int MOD = (int) 1e9 + 7;

    /**
     * {dp} i列一共有四种状态
     * 
     * @param n
     * @return
     */
    public int numTilings(int n) {
        // 创建一个二维数组 f，第一维长度为 2，第二维长度为 4
        // 第一维用于滚动数组优化，减少空间复杂度，因为状态转移只依赖前一行
        // 第二维的 4 个状态表示第 i 列的不同覆盖情况
        int[][] f = new int[2][4];
        // 初始化第一列的状态
        // f[1][0] 表示第 1 列两行都未覆盖的情况，初始化为 1
        // f[1][1] 表示第 1 列两行都覆盖的情况，初始化为 1
        f[1][0] = f[1][1] = 1;
        // 从第 2 列开始递推到第 n 列
        for (int i = 2; i <= n; i++) {
            // a 表示当前列的索引，b 表示前一列的索引
            // 使用位运算 i & 1 和 (i - 1) & 1 实现滚动数组，交替使用 0 和 1 作为索引
            int a = i & 1, b = (i - 1) & 1;
            // f[a][0] 表示当前列两行都未覆盖的情况，只能由前一列两行都覆盖的情况转移过来
            f[a][0] = f[b][1];
            // cur 用于累加前一列所有状态的方案数
            int cur = 0;
            // 遍历前一列的 4 种状态，累加方案数并对 MOD 取模
            for (int j = 0; j < 4; j++)
                cur = (cur + f[b][j]) % MOD;
            // f[a][1] 表示当前列两行都覆盖的情况，由前一列所有状态转移过来
            f[a][1] = cur;
            // f[a][2] 表示当前列只有上一行被覆盖的情况，由前一列两行都未覆盖和下一行被覆盖的情况转移过来
            f[a][2] = (f[b][0] + f[b][3]) % MOD;
            // f[a][3] 表示当前列只有下一行被覆盖的情况，由前一列两行都未覆盖和上一行被覆盖的情况转移过来
            f[a][3] = (f[b][0] + f[b][2]) % MOD;
        }
        // 最终结果为第 n 列两行都覆盖的方案数
        return f[n & 1][1];
    }
}
